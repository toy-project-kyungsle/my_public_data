
> 애슬러 앱 코드베이스(`athler-apps`)를 실제로 분석한 결과를 기반으로 한 개선 아이디어 목록.
> ACTION_PENDING.md에서 참조하는 상세 문서.

---

## 1. TypeScript 엄격 모드 강화

### 현황

- `tsconfig.base.json`에 `strict: true` 설정 (기본 토대는 잡혀 있음)
- `skipLibCheck: true` 설정 (의존성 타입 체크 스킵)
- `noImplicitAny`, `noUnusedLocals`, `noUnusedParameters`, `noImplicitReturns` 미설정
- 패키지별 tsconfig는 base를 상속하지만 추가적인 엄격 규칙 없음

### 왜 필요한가

- 암묵적 `any` 타입이 허용되면 런타임에서야 발견되는 타입 에러가 발생
- 사용하지 않는 변수/파라미터가 남아있으면 코드 이해도 저하
- 모든 코드 경로에서 반환값을 보장하지 않으면 예상치 못한 `undefined` 반환

### 실행 방법

```
단계적 적용 순서:
1. ui-system (범위 작고, 컴포넌트 중심)
2. lib-business (비즈니스 로직, 영향도 높음)
3. package-athler-js (코어, 가장 큰 패키지)
4. app-athler-native / app-athler-web (앱 레벨)
```

**추가할 설정:**
```json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true
  }
}
```

### 관련 파일
- `tsconfig.base.json`
- 각 패키지의 `tsconfig.json`

---

## 2. 테스트 커버리지 강화

### 현황

- `package-athler-js` 기준: 테스트 파일 약 38개 / 소스파일 약 1,595개 (약 2.4%)
- `jest --passWithNoTests` 옵션이 패키지 스크립트에 설정되어 테스트 없는 패키지도 통과
- 디스플레이 컴포넌트 129개에 테스트 커버리지 거의 없음
- 커버리지 임계값(threshold) 미설정

### 왜 필요한가

- 핵심 비즈니스 로직(결제, 쿠폰, 장바구니)에 테스트가 부족하면 회귀 버그 위험
- `--passWithNoTests`가 테스트 작성 동기를 약화시킴
- 커버리지 임계값이 없으면 커버리지가 점점 낮아지는 경향

### 실행 방법

**1단계: 커버리지 임계값 설정**
```javascript
// jest.config.js
coverageThreshold: {
  global: {
    branches: 30,   // 시작점 (점진적으로 올림)
    functions: 30,
    lines: 30,
    statements: 30
  }
}
```

**2단계: 우선 테스트 대상 선정**

| 우선순위 | 대상 | 이유 |
|----------|------|------|
| 1 | API query 함수 (query-fn/*) | 서버 통신의 정합성 |
| 2 | zustand 스토어 | 상태 관리 로직 |
| 3 | 비즈니스 유틸리티 함수 | 계산/변환 로직 |
| 4 | 에러 핸들링 경로 | 장애 대응 코드 |

**3단계: CI 통합**
- 핵심 패키지(`package-athler-js`, `lib-business`)에서 `--passWithNoTests` 제거
- PR 차단 기준 설정

### 관련 파일
- 각 패키지의 `jest.config.js` 또는 `jest.config.ts`
- `package.json` (test 스크립트)
- `.github/workflows/pr-checks.yml`

---

## 3. 순환 의존성 제거

[[순환_의존성_픽스의_중요성]]

### 현황

- `CircularDependencyPlugin`이 webpack 설정에 존재하나 warning만 출력
- 알려진 순환 참조:
  - `home-display.tsx` → `@athlerjs/store/react-query` (코드 주석에 "순환 참조 해결 필요")
  - `header-token` → API index export에서 순환 유발 (API index에서 제외하여 우회 중)
- 코드베이스에 4개의 TODO 주석이 순환 참조 관련

### 왜 필요한가

- 순환 의존성은 번들 크기 증가, 초기화 순서 문제, 런타임 에러의 원인
- Warning만 출력하면 새로운 순환 참조가 계속 추가됨

### 실행 방법

**1단계: 현황 파악**
- `webpack --config ... --json` 으로 현재 순환 참조 전체 목록 추출
- 각 순환 참조의 영향도 평가

**2단계: 리팩터링**
- 브릿지 모듈 패턴 적용 (공통 타입/인터페이스를 별도 파일로 분리)
- re-export 패턴 정리 (index.ts에서 자기 자신을 import하는 모듈 import하지 않기)

**3단계: CI 차단**
```javascript
// webpack.config.js (개발 환경)
new CircularDependencyPlugin({
  failOnError: true,
  exclude: /node_modules/,
})
```

### 관련 파일
- `packages/app-athler-web/config/webpack.config.js`
- `packages/package-athler-js/src/store/` (react-query 관련)
- API 관련 index 파일들

---

## 4. Error Boundary 확장

### 현황

- 전체 앱에 Sentry ErrorBoundary 1개만 존재 (`App.tsx`)
- 17개의 TODO/FIXME 주석 중 일부가 에러 핸들링 관련
- 표준화된 에러 복구 패턴 없음

### 왜 필요한가

- 하나의 에러가 전체 앱을 크래시시킬 수 있음
- 특정 영역(SDUI, Braze 인앱 메시지)의 에러가 핵심 커머스 플로우를 방해
- 에러 타입별 다른 UX 제공 불가 (현재는 전체 에러 페이지만)

### 실행 방법

**레벨별 ErrorBoundary 추가:**

| 레벨 | 대상 | 폴백 UI |
|------|------|---------|
| 앱 전체 | App.tsx (기존) | 에러 페이지 + 새로고침 |
| 라우트 | 주요 화면별 (상품, 프로모션, 주소 등) | 화면별 에러 메시지 + 재시도 |
| 영역 | SDUI 디스플레이 렌더링 | 해당 영역만 숨김/대체 |
| 위젯 | Braze 인앱 메시지, 추천 영역 | 조용히 숨김 (핵심 아님) |

**에러 타입 계층 설계:**
```typescript
// 예시 구조
class AppError extends Error { /* base */ }
class NetworkError extends AppError { /* 네트워크 */ }
class ValidationError extends AppError { /* 유효성 */ }
class ServerError extends AppError { /* 서버 5xx */ }
class BusinessError extends AppError { /* 비즈니스 규칙 */ }
```

### 관련 파일
- `packages/app-athler-native/src/App.tsx`
- 각 라우트 컴포넌트
- `packages/package-athler-js/src/display/` (SDUI 디스플레이)

---

## 5. 메모이제이션 전략

### 현황

- 425개 `useEffect` 사용
- 129개 디스플레이 컴포넌트에 체계적 메모이제이션 전략 없음
- React.memo/useMemo/useCallback 사용이 약 1,351건이나 체계적이지 않음

### 왜 필요한가

- 불필요한 리렌더링은 스크롤 잔렉, 입력 지연 등 UX 저하의 직접적 원인
- SDUI 스키마 변환은 무거운 연산이므로 메모이제이션이 필수
- 리스트 아이템에 메모이제이션이 없으면 전체 리스트가 리렌더링

### 실행 방법

**메모이제이션 적용 기준:**

| 상황 | 적용 | 이유 |
|------|------|------|
| 디스플레이 컴포넌트 | `React.memo` | props 안정적, 부모 리렌더 시 불필요 렌더 방지 |
| SDUI 스키마 변환 | `useMemo` | 연산 비용 높음 |
| 리스트 아이템 | `React.memo` | 리스트 스크롤 성능 |
| 이벤트 핸들러 → memo 자식 | `useCallback` | 참조 안정성 보장 |
| 단순 값 계산 | 적용 불필요 | 오버헤드가 이득보다 큼 |

> React Compiler(v1.0)가 이 과정을 자동화할 수 있으므로, 장기적으로는 React Compiler 도입도 검토

### 관련 파일
- `packages/package-athler-js/src/display/` (129개 디스플레이 컴포넌트)
- SDUI 스키마 관련 유틸리티

---

## 6. Zustand 스토어 정리

### 현황

- 14개 zustand 스토어가 각 라우트에 산재
  - `address-list-callback-store`
  - `page-param-store`
  - 기타 라우트별 로컬 스토어
- 서버 상태(React Query)와 UI 상태(Zustand) 경계가 불명확
- 스토어 네이밍/위치 컨벤션 불통일

### 왜 필요한가

- 상태 관리 패턴이 불일치하면 디버깅이 어려움
- 서버 상태가 Zustand에도 있고 React Query에도 있으면 동기화 문제
- 새로운 개발자가 상태 구조를 파악하기 어려움

### 실행 방법

**1단계: 상태 감사(Audit)**
- 14개 스토어가 관리하는 상태를 서버 상태 vs UI 상태로 분류
- 서버 상태인데 Zustand에 있는 것 → React Query로 이전

**2단계: 컨벤션 통일**
- 파일명: `*.store.ts`
- 위치: 공통 → `src/store/`, 라우트 전용 → 해당 라우트 폴더 내
- 네이밍: `use[도메인]Store` 패턴

**3단계: 스토어 팩토리 또는 미들웨어 표준화**
- devtools, persist 등 미들웨어 적용 패턴 통일
- 로깅 미들웨어 추가 (Sentry breadcrumb 연동)

### 관련 파일
- `packages/package-athler-js/src/` 내 `*store*` 파일들
- zustand 관련 설정

---

## 7. ESLint 규칙 강화

### 현황

- 루트 `.eslintrc`에 좋은 규칙들이 있음 (no-unused-imports, import/order, import/no-cycle)
- Logger 사용 강제, Date 제한, DOM API 제한 등 커스텀 규칙 존재
- 일부 패키지의 `.eslintrc`는 루트만 extends

### 추가할 규칙

| 규칙 | 목적 | 중요도 |
|------|------|--------|
| `@typescript-eslint/no-floating-promises` | 처리되지 않은 Promise rejection 방지 | 높음 |
| `@typescript-eslint/explicit-return-types` | API/스토어 함수 반환 타입 명시 | 중간 |
| `react-hooks/exhaustive-deps` 검증 강화 | useEffect 의존성 배열 실수 방지 | 높음 (2회 사고 이력) |
| 패키지별 import 제한 | lib-business에서 UI import 금지 | 중간 |
| 파일 네이밍 규칙 | 스토어(*.store.ts), 훅(use*.ts) 등 | 낮음 |

### 관련 파일
- `.eslintrc` (루트)
- 각 패키지의 `.eslintrc`

---

## 8. CI/CD 파이프라인 강화

### 현황

- `.github/workflows/pr-checks.yml`에 기본 검증만 존재 (lint, test, web:build)
- Node 18 사용 중 (프로젝트는 >=22 요구)
- 단일 작업으로 순차 실행 (병렬화 없음)

### 개선 사항

| 항목 | 현재 | 개선 후 |
|------|------|---------|
| Node 버전 | 18 | 22+ |
| 작업 구조 | 단일 순차 | lint/typecheck/test 병렬 |
| 커버리지 | 없음 | Codecov 연동 |
| 번들 크기 | 없음 | PR별 비교 |
| 타입 체크 | lint에 포함 | 전용 작업 분리 |
| 보안 스캔 | 없음 | yarn audit / Dependabot |

### 관련 파일
- `.github/workflows/pr-checks.yml`
- `package.json` (scripts)

---

## 9. 번들 최적화

### 현황

- webpack 설정에 BundleAnalyzerPlugin, TerserPlugin, CssMinimizerPlugin 존재
- 이미지 인라인 제한 10KB
- CSS 추출 설정 있음
- Sentry, Braze, Firebase 등 대형 서드파티 라이브러리 다수

### 개선 사항

**코드 스플리팅:**
- 라우트 기반 청크 분리 (address-list, product, promotion-list 등)
- 대형 의존성 별도 청크 (Braze, Firebase Analytics 등)
- dynamic import 활용

**번들 모니터링:**
- `ANALYZE=true` 빌드 옵션으로 분석 가능하도록 스크립트 추가
- CI에서 PR별 번들 크기 비교
- 청크별 사이즈 예산 설정

**네이티브 최적화:**
- Hermes 컴파일러 활용 확인 (RN 0.81 + New Architecture)
- OTA 번들 크기 프로파일링 (hdiff-patch 내장)

### 관련 파일
- `packages/app-athler-web/config/webpack.config.js`
- 각 패키지의 `package.json`

---

## 10. React Query 최적화

### 현황

- 360개 이상의 useQuery/useMutation 호출
- staleTime/gcTime 전략이 통일되지 않음
- keepPreviousData 활용 부족

### 개선 사항

**쿼리 옵션 표준화:**

| API 특성 | staleTime | gcTime | 예시 |
|----------|-----------|--------|------|
| 자주 바뀌는 데이터 | 0 | 5분 | 재고, 가격 |
| 가끔 바뀌는 데이터 | 5분 | 30분 | 상품 정보 |
| 거의 안 바뀌는 데이터 | 30분 | 1시간 | 카테고리, 배너 설정 |
| 사용자별 데이터 | 1분 | 10분 | 장바구니, 쿠폰 |

**추가 최적화:**
- `keepPreviousData: true`로 화면 깜빡임 방지 (리스트 페이지네이션)
- `prefetchQuery`로 다음 화면 데이터 선제 로딩
- 쿼리 키 팩토리 패턴 도입으로 키 관리 일관성 확보
- in-flight deduplication 패턴 점검

### 관련 파일
- `packages/package-athler-js/src/query-fn/` (API 쿼리 함수)
- React Query 관련 설정/프로바이더

---
## 우선순위 매트릭스

[[코드_개선/준프_책을_통해서_공부한_것을_적용할_수_있는_곳]]
[[Eisenhower Matrix]]

| # | 항목 | 영향도 | 난이도 | 추천 순서 |
|---|------|--------|--------|-----------|
| 1 | TypeScript 엄격 모드 | 높음 | 낮음 | 1순위 |
| 2 | 테스트 커버리지 | 높음 | 중간 | 2순위 |
| 3 | 순환 의존성 | 높음 | 중간 | 3순위 |
| 4 | Error Boundary | 중간 | 낮음 | 4순위 |
| 7 | ESLint 규칙 | 중간 | 낮음 | 5순위 |
| 5 | 메모이제이션 | 중간 | 중간 | 6순위 |
| 10 | React Query 최적화 | 중간 | 중간 | 7순위 |
| 6 | Zustand 정리 | 낮음 | 중간 | 8순위 |
| 8 | CI/CD 강화 | 중간 | 중간 | 9순위 |
| 9 | 번들 최적화 | 중간 | 중간 | 10순위 |
