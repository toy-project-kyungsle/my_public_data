분석이 완료되었습니다. 현재 상황과 해결 방법론을 정리하겠습니다.

---

## 현재 상황 요약

`madge`로 분석한 결과 **49개 순환참조**가 `package-athler-js`에 존재합니다. 7개 클러스터로 분류됩니다:

|클러스터|개수|위치|
|---|---|---|
|display/types ↔ display/schema|16|가장 큰 문제|
|display/components ↔ hooks|10||
|analytics 내부|9||
|routes 내부|7||
|payment/promotion|4||
|api/auth|3||
|**패키지 레벨**: athler-js ↔ athler-web|1|package.json에 선언만 됨|

---

## 방법론: 패턴별 해결 전략

### 1. **타입과 구현의 분리** (display/types ↔ display/schema 해결)

가장 큰 16개 순환의 핵심 원인입니다:

```
display/types/display.ts → display/schema/index.ts → display/schema/display.ts 
  → display/schema/scroll-schema.ts → display/types/index.ts → ... → 처음으로
```

**문제**: 타입 정의 파일이 스키마(구현)를 참조하고, 스키마가 다시 타입을 참조합니다.

```typescript
// ❌ 현재: types가 schema를 import
// display/types/display.ts
import { displaySchema } from '../schema';  // 구현을 참조
export type Display = z.infer<typeof displaySchema>;

// display/schema/display.ts  
import { BannerType } from '../types';  // 다시 타입을 참조 → 순환!
```

**해결: 타입을 독립적인 진실의 원천으로**

```typescript
// ✅ 방법 A: 타입을 먼저 정의하고, 스키마는 타입만 참조
// display/types/display.ts - 어떤 schema도 import하지 않음
export interface Display {
  banners: Banner[];
  scrollType: ScrollType;
}

// display/schema/display.ts - 타입만 import (단방향)
import type { Display } from '../types';
export const displaySchema: z.ZodType<Display> = z.object({...});
```

```typescript
// ✅ 방법 B: z.infer 대신 별도 타입 파일 사용
// display/types/base.ts - 순수 타입만, import 없음
export type ScrollType = 'vertical' | 'horizontal' | 'grid';
export type BannerType = 'image' | 'video';

// display/types/display.ts
import type { ScrollType, BannerType } from './base';  // 내부만 참조
export interface Display { ... }

// display/schema/display.ts
import type { Display } from '../types';  // 단방향
```

**원칙**: 타입은 구현(schema, validator)을 몰라야 합니다. 의존 방향은 항상 `schema → types` 단방향입니다.

---

### 2. **공유 상수/타입 추출** (2-file 상호참조 해결)

가장 쉽게 고칠 수 있는 패턴입니다. 49개 중 약 10개가 해당됩니다.

```typescript
// ❌ 현재: 두 파일이 서로를 import
// onboarding/type.ts
import { ONBOARDING_STEPS } from './constants';
export type Step = typeof ONBOARDING_STEPS[number];

// onboarding/constants.ts
import type { OnboardingConfig } from './type';
export const ONBOARDING_STEPS = [...] as const;
```

**해결: 제3의 파일로 공유 요소 추출**

```typescript
// ✅ onboarding/shared.ts - 공유 원천
export const ONBOARDING_STEPS = [...] as const;
export type Step = typeof ONBOARDING_STEPS[number];

// onboarding/type.ts - shared만 참조
import { Step } from './shared';
export interface OnboardingConfig { step: Step; ... }

// onboarding/constants.ts - shared만 참조
import { ONBOARDING_STEPS } from './shared';
```

```
Before:  A ↔ B  (순환)
After:   A → C ← B  (C가 공유 원천)
```

이 패턴으로 해결 가능한 것들:

- `onboarding/type.ts` ↔ `constants.ts`
- `my-points-route.tsx` ↔ `elems.tsx`
- `product-option-context.ts` ↔ `on-type-select.ts`
- `order-request/__modals__/index.tsx` ↔ `modal-order-coupon-sub.tsx`

---

### 3. **의존성 역전 (Dependency Inversion)** (analytics, payment 해결)

콜백이나 인터페이스를 통해 의존 방향을 뒤집는 방법입니다.

```typescript
// ❌ 현재: event-logger가 swiper-logger를 알고, swiper-logger가 다시 event-logger를 알음
// event-logger.ts
import { setSwiperVisible } from './swiper-logger/set-swiper-visible-change';

// swiper-logger/set-swiper-visible-change.ts
import { logEvent } from '../event-logger';  // 순환!
```

**해결: 인터페이스/콜백으로 역전**

```typescript
// ✅ 방법 A: 콜백 주입
// swiper-logger/set-swiper-visible-change.ts
// event-logger를 직접 import하지 않음
export function createSwiperVisibleHandler(
  logEvent: (name: string, params: Record<string, unknown>) => void
) {
  return (visible: boolean) => {
    logEvent('swiper_visible', { visible });
  };
}

// event-logger.ts (단방향으로 조립)
import { createSwiperVisibleHandler } from './swiper-logger/set-swiper-visible-change';
const handleSwiperVisible = createSwiperVisibleHandler(logEvent);
```

```typescript
// ✅ 방법 B: 인터페이스 분리
// types/event-logger.ts - 인터페이스만
export interface EventLogger {
  logEvent: (name: string, params: Record<string, unknown>) => void;
}

// swiper-logger/set-swiper-visible-change.ts
import type { EventLogger } from '../types/event-logger';  // 타입만 의존
export function setSwiperVisible(logger: EventLogger, visible: boolean) {
  logger.logEvent('swiper_visible', { visible });
}

// event-logger.ts
import { setSwiperVisible } from './swiper-logger/...';  // 단방향
```

**원칙**: 하위 모듈이 상위 모듈을 직접 import하지 않고, 인터페이스에 의존합니다.

---

### 4. **Barrel 파일 분할** (components 순환 해결)

현재 `components/index.ts`가 거대한 barrel로 모든 것을 re-export하면서, 하위 컴포넌트가 다시 barrel을 import하는 패턴입니다.

```typescript
// ❌ 현재
// components/index.ts
export * from './atom';
export * from './navigation';
export * from './modal';
// ... 수십개 re-export

// components/navigation/headers/big-luck-top-tab.tsx
import { HEADER_HEIGHTS } from '@athlerjs/components';  // 전체 barrel 참조!
```

**해결: 직접 경로 import**

```typescript
// ✅ barrel 대신 직접 경로로 import
// components/navigation/headers/big-luck-top-tab.tsx
import { HEADER_HEIGHTS } from '../constants';  // 직접 참조
```

**또는 barrel을 도메인별로 분할:**

```typescript
// components/atom/index.ts       - atom만
// components/navigation/index.ts  - navigation만  
// components/modal/index.ts       - modal만

// 하위 파일은 자기 도메인 barrel만 참조 가능
// components/navigation/headers/big-luck-top-tab.tsx
import { HEADER_HEIGHTS } from '@athlerjs/components/navigation';
```

---

### 5. **패키지 레벨 순환 제거** (athler-js ↔ athler-web)

```
athler-js (package.json) → athler-web → athler-js  (순환!)
```

실제 코드에서는 import하지 않지만 `package.json`에 선언되어 있습니다. 단순 제거하면 됩니다.

---

## 작업 우선순위 제안

```
1순위 (빠른 성과)
├── package.json에서 athler-web 의존성 제거 (1개 순환 제거)
├── 2-file 상호참조 6건 → 공유 파일 추출 (6개 순환 제거)
└── ESLint import/no-cycle를 "error"로 변경 (재발 방지)

2순위 (중간 난이도)
├── analytics 내부 순환 9건 → 의존성 역전/콜백 주입
├── api/auth 순환 3건 → 인터페이스 분리
└── payment/promotion 순환 4건

3순위 (가장 큰 효과, 가장 큰 노력)
├── display/types ↔ schema 순환 16건 → 타입과 구현 분리
└── display/components ↔ hooks 순환 10건 → barrel 분할 + 직접 경로
```

어떤 클러스터부터 시작할지 결정하시면, 실제 코드를 보면서 하나씩 리팩토링을 진행할 수 있습니다.