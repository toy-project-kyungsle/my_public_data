개발자가 설계 단계에서 가장 경계해야 할 것은 **"데이터가 논리적으로 말이 안 되는 상태"**가 되는 것입니다. 언급하신 세 가지 개념은 TypeScript의 타입 시스템을 이용해 이런 버그를 코딩 시점에 원천 차단하는 기법들입니다.

하나씩 쉽게 풀어드릴게요.

---

## 1. 유니온 상태 머신 (Union State Machine)

상태를 단순히 `string`으로 정의하면 `‘결제완료’` 상태에서 갑자기 `‘장바구니’` 상태로 되돌아가는 등의 말도 안 되는 상황을 막을 수 없습니다.

**유니온 상태 머신**은 각 상태를 독립된 객체 타입으로 정의하고, 이를 유니온(`|`)으로 묶어 **특정 상태에서만 존재할 수 있는 데이터**를 강제하는 방식입니다.

* **AS-IS (위험):** `status: string;` (결제도 안 했는데 결제일자가 들어올 수 있음)
* **TO-BE (안전):**
```typescript
type OrderStatus = 
  | { status: 'PENDING' } // 대기 중에는 결제일자 없음
  | { status: 'PAID'; paidAt: Date; amount: number } // 결제 완료시에만 paidAt 존재
  | { status: 'CANCELLED'; reason: string }; // 취소시에만 사유 존재

```



이렇게 하면 `status`가 `PENDING`일 때 실수로 `paidAt`에 접근하려 하면 컴파일 에러가 납니다. **"불가능한 상태"를 타입 수준에서 지워버리는 거죠.**

---

## 2. 브랜디드 타입 (Branded Type)

TypeScript의 타입 시스템은 기본적으로 **구조적 타이핑(Structural Typing)**입니다. 즉, 이름이 달라도 내부 구조(예: 둘 다 `number`)가 같으면 같은 타입으로 취급합니다.

예를 들어, `결제금액(KRW)`과 `할인쿠폰ID(number)`가 둘 다 `number`라면, 실수로 금액 자리에 쿠폰 ID를 넣어도 컴퓨터는 모릅니다. **브랜디드 타입**은 여기에 "낙인(Brand)"을 찍어 구분합니다.

* **코드 예시:**
```typescript
type Brand<K, T> = K & { __brand: T };

type Amount = Brand<number, 'Amount'>;
type CouponId = Brand<number, 'CouponId'>;

let price = 10000 as Amount;
let coupon = 123 as CouponId;

price = coupon; // ❌ 에러 발생! (서로 다른 '낙인'이 찍혀 있음)

```



단순한 숫자가 아니라 **의미가 담긴 타입**으로 격상시켜 단위 혼동이나 형 변환 실수를 방지합니다.

---

## 3. Money 객체 (Value Object)

브랜디드 타입보다 한 단계 더 나아가, 금액 계산 로직 자체를 객체 안에 가두는 방식입니다.

금액은 단순히 숫자가 아니라 **통화 단위(KRW, USD)**와 **소수점 처리 규칙**이 필요합니다. 이를 `number`로 직접 계산하지 않고 `Money`라는 클래스나 객체에 맡깁니다.

* **핵심 원칙:**
1. **불변성:** 금액을 변경할 때는 항상 새로운 `Money` 객체를 반환합니다.
2. **유효성 검증:** 음수 금액이 생성되는 것을 생성 단계에서 막습니다.
3. **전용 메서드:** `money.add(otherMoney)` 같은 메서드만 제공하여 비즈니스 로직의 일관성을 유지합니다.



---

### 요약하자면

| 개념 | 목적 | 효과 |
| --- | --- | --- |
| **유니온 상태머신** | 잘못된 상태 전이 방지 | "결제 안 된 주문에 결제일이 있는" 모순 제거 |
| **브랜디드 타입** | 원시 타입 간 혼동 방지 | "ID와 금액"처럼 같은 숫자형의 오용 방지 |
| **Money 객체** | 도메인 로직 캡슐화 | 통화 계산 실수 및 부적절한 산술 연산 방지 |

이 개념들을 적용하면 **"컴파일만 되면 비즈니스 로직의 절반은 맞다"**는 확신을 가질 수 있습니다. 혹시 실제 업무 중인 코드에 적용해보고 싶은 구체적인 사례가 있으신가요? 직접 리팩토링 예시를 짜드릴 수 있습니다.