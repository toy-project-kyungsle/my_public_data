> [!NOTE] 일단 무엇을 봐야 하는가를 체크해본다
> 이 것들 중에서 지표가 이상하다 싶은 것들에 대한 코드적 개선이 있으면 되지 않을까?

# 앱 안정성을 측정할 수 있는 방법

## 1) RN 앱 “안정성”을 4종류로 나눠서 측정하기

RN은 JS + 네이티브가 섞여 있어서, 안정성도 아래 4개가 섞여 터져.

### A. 크래시(네이티브/치명적)

> [!NOTE] 확인 완료
> 크래시도 0.19% (안드로이드 기준) 이고 센트리로 봐도 낮아보여서 괜찮아보임

    •	가장 대표 지표: Crash-free sessions / Crash-free users

예를 들어 Sentry는 “크래시로 끝나지 않은 세션 비율”을 crash-free sessions로 정의해. ￼
Crashlytics도 crash-free users 계산식을 문서로 명시해. ￼

지금 액션
• 앱 버전(릴리즈) 기준으로 crash-free sessions/users를 기본 대시보드 1번 칸에 고정
• “신규 릴리즈 후 1~2시간” 구간만 따로 보는 뷰를 만들기(릴리즈 회귀 탐지용)

⸻

### B. 멈춤/프리즈(ANR 계열: 특히 Android)

> [!NOTE] 확인 완료
> ANR 관련해서 지금 0% 수준을 보여주고 있어서 딱히 무언가를 할 필요가 없어보인다.

Android는 UI 스레드가 너무 오래 막히면 **ANR(Application Not Responding)**이 난다. ￼
이건 “크래시”가 아니라 앱이 얼어붙어 유저가 강제 종료하는 케이스라 전환에 치명적.

지금 액션
• Android에서 **ANR율/ANR 발생 Top 화면(또는 액션)**을 별도 지표로 둔다(크래시와 분리)
• “리스트 스크롤/검색 입력/결제 화면 전환” 같은 체감 병목 구간을 ANR 관점으로 점검(무거운 동기 작업/큰 렌더/이미지 디코딩 등)

⸻

### C. JS 레벨 치명 오류(렌더 에러, 전역 예외, Promise 미처리)

RN에서 “앱은 안 죽었는데 화면이 깨지는” 주된 원인이 이쪽이야.

지금 액션(필수 3종 세트) 1. Error Boundary: 렌더 에러를 화면 단위로 격리 + 복구 UI 제공 2. 전역 에러 핸들러: 잡히지 않은 JS 에러 수집(릴리즈/화면 태그 포함) 3. Unhandled Promise Rejection 수집: RN에서 특히 놓치기 쉬움
Sentry도 “미처리 Promise rejection 핸들러가 제대로 안 붙으면 경고가 날 수 있다”고 따로 문서화해. ￼

이 3개가 없으면 “코드가 불안정한데도 크래시 지표는 멀쩡”한 착시가 생겨.

⸻

### D. 기능 실패(커머스 안정성)

“앱이 살아있어도 돈이 새는 실패”가 있어.
• 결제/쿠폰/로그인/장바구니에서 실패 이벤트는 크래시가 아니어도 P0 이슈야.

지금 액션
• 4대 플로우 각각에 실패율 SLI를 최소 1개씩 고정(예: checkout_attempt 대비 성공, coupon_apply 성공률, login_refresh 성공률, cart_update 성공률)
• 실패 시 “재시도/복구 UX”가 있는지 함께 점검(안정성은 실패를 “복구 가능”하게 만드는 설계까지 포함)

⸻

## 2) “상황 측정”을 제대로 하려면: 릴리즈 상관관계가 1순위

안정성 지표는 버전/빌드와 묶이지 않으면 원인 추적이 거의 불가능해.

지금 액션
• 모든 에러/크래시/ANR/JS오류에 공통 태그를 강제:
• release_version, build_number
• os, device_model
• (커머스라면) flow_step(search/pdp/cart/checkout/login)
• “이슈가 늘었다”가 아니라 **“특정 릴리즈에서 늘었다”**로 말할 수 있게 만들기

⸻

## 3) 코드 안정성을 “정량화”하는 최소 스코어카드(이거만 잡아도 P0가 올라감)

아래 6개만 꾸준히 보면 “측정→개선” 루프가 돈다. 1. crash-free sessions (릴리즈별) ￼ 2. crash-free users (릴리즈별) ￼ 3. Android ANR율(릴리즈별) ￼ 4. JS fatal(전역 에러/렌더 크래시) 발생률 5. unhandled promise rejection 발생률 ￼ 6. 4대 플로우 “기능 실패율”(결제/쿠폰/로그인/장바구니)

포인트: (1~5)는 “기술 안정성”, (6)은 “비즈니스 안정성”이라 둘 다 봐야 P0가 된다.

⸻

## 4) 측정 다음은 “개선이 돈 되는” 정렬 방식

안정성 개선은 보통 “몇 건 고쳤다”가 아니라 얼마나 많은 유저/세션을 구했나가 중요해.

지금 액션
• 버그/크래시는 항상 이 기준으로 우선순위를 매겨: 1. 영향 유저 수(또는 세션 수) 2. 핵심 플로우 여부(체크아웃/로그인 우선) 3. 특정 릴리즈에서 회귀인지(급증이면 최우선)

⸻

## 5) 회귀를 막는 “코드 레벨 게이트” (측정과 함께 있어야 P0가 굳어짐)

측정만 하고 회귀하면 끝이야. RN에서 효과 좋은 게이트는 아래 3개. 1. TypeScript/ESLint를 ‘고위험 폴더’만이라도 더 엄격하게
• 결제/쿠폰/인증/네비게이션/딥링크 주변을 먼저 2. E2E 2~3개만 고정
• 로그인→장바구니→결제 시작(또는 완료)
• 쿠폰 적용 성공/실패 각각 1개
• 딥링크 진입 1개(민감 화면은 서버 확인 포함) 3. “릴리즈 후 지표 악화 시 즉시 중단” 규칙
• 새 릴리즈에서 crash-free/ANR/JS fatal이 튀면 확장 배포 중단(정책)

# 코드 안정성을 볼 수 있는 추가 스코어들

추가로 보자면 아래의 것들이 있다

7. 배터리/백그라운드 기상(wake) 이상 징후
   Android 쪽은 Play Console의 **Android Vitals “Core vitals”**에 사용자 체감 크래시율/ANR율 외에도 excessive partial wake locks 같은 항목이 포함돼(앱이 백그라운드에서 과하게 깨움 → 배터리/체감 품질 악화). ￼
   • “코드가 멀쩡한데 사용자 만족도/평점이 떨어지는” 패턴에서 원인이 되는 경우가 많아.

8. 앱 시작 실패(시작 직후 크래시/화이트스크린) 비율
   크래시 자체는 (1)(2)로 잡히지만, 운영적으로는 “시작하자마자 죽는/빈 화면 되는” 유형을 따로 보는 게 유용해.
   • 예: “세션 시작 N초 이내 크래시”, “초기화 단계 JS fatal” 같은 식으로 분리
   (구현은 너희가 이미 말한 JS 전역 에러/Boundary fallback 이벤트로 가능)

9. iOS Hang/OOM/Watchdog 같은 ‘크래시가 아닌 종료/멈춤’
   Android는 (3) ANR로 잡히는데, iOS는 크래시/ANR처럼 딱 떨어지는 지표가 대시보드에 안 보이는 경우가 많아서 MetricKit 같은 진단 채널을 고려할 가치가 있어(크래시/행(hang) 진단 등). ￼
   • “크래시프리 높아 보이는데 유저는 ‘멈췄다’고 하는” 케이스에서 도움 됨.

10. “다중 크래시 사용자” 비율(=crash loop 성향)
    단일 크래시보다 같은 유저가 짧은 시간에 여러 번 크래시를 겪는 케이스는 체감이 훨씬 나빠.
    Google Play의 크래시율은 “일일 사용자 기반으로 정규화된 비율”로 보는 방식이라, 이걸 보완하려고 “특정 유저가 반복적으로 당하는가”를 분리해 보는 게 좋아. ￼

11. 기기/OS/앱버전 편향(“특정 세그먼트만 박살”)
    이건 “새 지표”라기보다 모든 지표를 반드시 쪼개보는 관측 규칙이야.
    • 예: Android 14 특정 제조사 + 특정 앱버전에서만 JS fatal 급증
    → 평균만 보면 놓침

12. (너희 상황에 특히 추천) 화이트스크린/복구 UI 노출률
