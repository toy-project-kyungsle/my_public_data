
> ⚠️ 이 문서는 가이드라인입니다. 우선순위에 대해서 '추상적인' 지침과 아이디어가 있습니다.
>
> 그래서 무엇을 할 것인지 궁금하면 [Action](ACTION.md) 문서를 참고하세요.

# 1. 로드맵 차트

> ❓ 쌓아나가고 있는 역량에 대한 우선순위 표


| 우선순위   | 테마                                                        | 왜 이게 먼저인가                                                                           | 핵심가치                                     | 달성 후 보상                                                                           |
| ------ | --------------------------------------------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------- | --------------------------------------------------------------------------------- |
| **P0** | **전문성: 신뢰성/유지보수 기본기** (TS·상태·테스트·리팩토링)                    | 패션 커머스는 결제/쿠폰/장바구니/로그인 등 **매출 플로우가 깨지면 즉시 손실/CS 폭증** → 어떤 고급 역량도 “안 깨지는 기반” 없이는 무의미 | **정합성/안정성** + 변경에 강한 코드(회귀 방지)           | 핵심 플로우 변경 후 회귀 버그가 거의 없고, 타입/테스트로 PR 단계에서 문제를 잡으며, 장애 발생 시 원인 범위를 빠르게 좁혀 해결까지 연결함 |
| **P0** | **AI 협업(가속기): 검증 루틴 포함**                                  | AI는 생산성을 올릴 수도 있지만 검증이 없으면 리워크/버그를 늘림 → **“품질 유지하며 빨라지는 습관”**을 먼저 만들어야 함            | **속도×품질 동시 개선**(리뷰·테스트·문서화 가속)           | AI 활용이 코드량 증가가 아니라 리드타임/리워크 감소로 나타나고, PR에 검증 체크리스트(테스트/엣지케이스/보안/로깅)가 정착됨          |
| **P1** | **KPI 중심 사고(커머스 임팩트 증명)**                                 | 커머스는 “기능 구현”이 아니라 **지표 변화가 곧 가치**. 같은 기능이라도 KPI를 움직일 줄 아는 사람이 임팩트를 만듦               | **기술→지표→매출**로 번역(검색 전환율·결제 이탈률·추천 CTR 등) | “검색 UI 0.5초 개선→구매 전환 N%↑”처럼 전·후 수치(또는 A/B 결과)로 설명 가능하고, 목표 KPI/가설/측정 방식이 명확함      |
| **P1** | **비즈니스 임팩트형 성능/UX** (웹 CWV + RN 체감 성능)                    | 속도/체감이 곧 이탈·전환·재방문에 직결. 패션 커머스는 이미지/리스트가 많아 성능 레버가 큼                                | **전환에 기여하는 성능 최적화**(측정→원인→개선)            | 웹(LCP/INP/CLS), 앱(RN: 스크롤 잔렉/스타트업 타임/JS thread 병목) 각각에서 전/후 수치와 개선 리포트가 남아 있음     |
| **P1** | **설계 트레이드오프 판단** (웹: 로직 실행 위치 / 공통: 네트워크·캐시·렌더 비용)        | “되게 만드는 것”을 넘어 **빠르고 싸게, 확장 가능하게** 만드는 판단이 미들~시니어를 가름                               | **비용·성능·복잡도의 최적점** 찾기                    | “왜 서버/클라로 나눴는지”, “왜 이 캐시/프리패치 전략인지”를 근거로 설명하고, 변경 시 영향 범위를 예측/관리함                 |
| **P2** | **확장성(Full-cycle Lite): BE/인프라 이해** (API 계약·배포·캐시·BFF/엣지) | 프론트가 전주기 흐름을 모르면 병목이 생김. 반대로 **API/배포/운영을 이해하면 영향력이 급격히 확장**                        | **전주기 책임(막히지 않음)** + 협업 효율               | API 계약(OpenAPI/스키마) 기반 변경 대응이 빠르고, 배포/롤백/환경/시크릿을 이해하며, 장애 시 BE/인프라와 원인 공조가 가능함    |
| **P2** | **운영/관측(Observability) & 릴리즈**                            | 장애=매출. 특히 앱은 스토어 배포/핫픽스/롤백까지 포함해 운영 역량이 곧 신뢰                                        | **빠른 탐지·진단·복구**(운영 우수성)                  | 에러/성능 로그에 사용자·세션·주문단계 컨텍스트가 잡혀 있고, 재현 어려운 이슈를 로그/지표로 해결한 사례가 있음                   |
| **P2** | **보안/리스크 방어** (웹 XSS/CSP, 앱 토큰·딥링크·웹뷰/SDK)                | 쿠폰 악용/계정 탈취/결제 흐름 취약점은 곧 비용. 기본 방어선이 없으면 확장/성능보다 먼저 터짐                              | **돈 새는 구멍 차단** + 리스크 관리                  | 보안 체크리스트/코드 규칙이 있고, 토큰 저장/세션 정책/딥링크·웹뷰·서드파티 SDK 리스크를 점검·설명할 수 있음                  |
| **P3** | **차별성: 접근성(A11y) 기반 해자**                                  | 글로벌/제휴/리스크 관점에서 접근성은 “선택”이 아니라 “의무/신뢰”. 아는 사람이 적어 희소                                | **규제 대응 + 사용자 포용 품질**                    | 컴포넌트 레벨 접근성 규칙(포커스/라벨/키보드)이 정착돼 있고, 자동 검사+수동 점검 루틴이 돌아감                           |
| **P3** | **차별성(선택): AI UX / 특수기술(Wasm/에디터/그래픽 등)**                 | 강력하지만 도메인 핏이 있을 때만 ROI가 큼. 기반 역량(P0~P2) 위에 올리는 프리미엄                                 | **대체 불가능한 무기**                           | “기술을 했다”가 아니라 검색/추천/콘텐츠 제작/CS 비용 등 실제 문제를 개선한 사례로 증명됨                             |

- **P0**: 지금 당장 없으면 일을 못 하거나(또는 큰 사고가 나는) **필수/기반 우선순위**
- **P1**: 갖추면 성과가 확 뛰고(연봉/역할 확장에 직결되는) **핵심 성장 우선순위**
- **P2**: 영향 범위를 넓히고 팀 내 입지를 키우는 **확장 우선순위**
- **P3**: 있으면 대체불가해지는 **차별화/해자 우선순위**

---

# 2. 로드맵에 대한 지침과 아이디어

> ❓ AI가 제공한 무엇을 하면 좋은지에 대한 아이디어. 나의 아이디어가 가끔 한스푼씩 올라간다.

## P0) **전문성과 안정성**

### 🤖 AI 아이디어

[P0/전문성과_안정성.md](docs/P0/idea/전문성과_안정성.md)

> **안정성 : 결제/쿠폰/장바구니/로그인 같은 매출 플로우가 "절대 깨지지 않게" 설계·구현·검증·배포까지 묶어서 책임지는 능력**
> 
> **전문성 : 불변식·타입 시스템·상태 분리·테스트 전략·레이어 격리를 활용해 "왜 안 깨지는지"를 설명·증명·재현할 수 있는 기술적 깊이**

- 불변식(절대 깨지면 안 되는 것) 3개씩 선언하고 PR에서 참조한다
- 타입(TS)으로 불가능한 상태를 표현하지 못하게 만들기 (유니온 + 상태머신)
- 서버 상태 vs UI 상태 경계를 명확히 분리한다
- "돈 새는 케이스"만 정확히 테스트한다 (도메인 단위 → 통합 → E2E 핵심 2~3개)
- ==실패는 반드시 "복구 가능한 상태"로 귀결시킨다 (토스트로 끝내지 않기)==
- 고위험 코드는 격리해서 리뷰/테스트 밀도를 올린다 (domain/services/ui 분리)
- HIGH 변경은 불변식 3개 + 테스트 1개 + 롤백 전략 명시

### 👷 개인 아이디어

- 가격 쿠폰 재고 결제 로그인 등이 핵심 퍼널이라고 볼 수 있다
  - 핵심 플로우를 어떻게 안 깨지게 코드나 시스템(센트리, firebase 등)으로 방어할 수 있는가?
- 코드에서 어떻게 하면 안정적인 설계를 할 수 있는가?
  - **타입**을 강하게 사용해서 코딩 에러를 코드 작성단에서 방지하기
  - 절대로 일어나서는 안 되는 것들 **테스트 코드** 작성하기
  - 테스트 코드를 또 잘 작성하려면 함수나 변수에 대한 **의존성 분리**가 잘 되어 있어야 한다
    - 인터페이스로 감싸고 의존성 주입하기. 준프 도서를 실사용화 할 수 있을 정도로 체화하기.
  - **lint**를 사용해서 혹시 모를 에러를 방지한다
  - **assert**와 **guard**함수를 사용해서 절대 발생하지 않아야 하는 것들을 체크한다
  - 실패를 설계한다
    - 점진적인 롤아웃 + 즉시 복구할 수 있는 포인트 설계민
    - 에러가 났을 때 고객한테 어떻게 보일 것인가 (페이지, 모달, 토스트, 고객센터 이동)
- **에러가 안 나게(또는 나도 안전하게) 만드는 설계/코딩 습관을 갖추는 것**

## P0) AI와 협업해서 개발하기

### 🤖 AI 아이디어

[P0/ai_협업_가속기_실제_방법.md](docs/P0/idea/ai_협업_가속기_실제_방법.md)

> **AI와 협업할 때 "검증 루틴"을 먼저 주고, 역할을 분리하며, 품질을 자동화 도구로 통제하는 습관**

- "검증 루프"를 먼저 준다 (테스트/기대 결과/로그 샘플을 AI에게 먼저 제공)
- 역할을 분리한다: 작성자 ≠ 리뷰어 ≠ 테스터 ≠ 릴리즈 매니저
- "불변식 → 실패 시나리오 → 구현" 순서를 고정한다
- KPI 작업은 "가설"보다 "측정 설계"를 먼저 시킨다
- 출력 형식을 고정해서 품질을 안정화한다
- 자동화 도구(테스트/린트/타입체크)를 "AI의 상사"로 만든다
- 릴리즈는 "에러율"이 아니라 "burn rate"로 관리한다
- 보안/민감정보는 "금지 규칙"으로 선제 봉인한다
- 프롬프트/체크리스트를 버전 관리해서 팀 자산화한다

## P1) **KPI 중심 사고(커머스 임팩트 증명)**

- mini PO가 되어보자
  - 가설 + 설계 + 개발 + 데이터 + 결과 보고
  - 이걸 모두 해서 수치를 개선하기

[P1/kpi_중심_사고.md](docs/P1/idea/kpi_중심_사고.md)

> **지표를 '의사결정 가능한 형태'로 정의하고, 변경/실험을 그 지표로 판정하고, 학습을 재사용 가능하게 남기는 습관**

- KPI를 "정의서"로 고정한다 (분자/분모/이벤트소스/윈도우/필터 6가지 필수)
- KPI를 "트리(Driver/Guardrail)"로 쪼개서 프론트 액션과 연결한다
- "기회 크기"를 먼저 계산해서 무엇부터 할지 결정한다
- 변경/실험을 "승리 조건 + 가드레일"로 설계한다 (숫자로 판정 가능하게)
- 분석은 "승리 보고"가 아니라 "의사결정 로그"로 남긴다
- 분모를 통제 가능한 단위로 설계하기 (전체 방문자 X → 플로우별 O)

## P1) **비즈니스 임팩트형 성능/UX** (웹 CWV + RN 체감 성능)

### 🤖 AI 아이디어
[P1/비즈니스_임팩트형_성능_ux.md](docs/P1/idea/비즈니스_임팩트형_성능_ux.md)

> **커머스 KPI(검색 전환율/결제 이탈률/추천 CTR)를 흔드는 병목을 찾아 제거하는 성능/UX 개선**

- 타겟을 "페이지"가 아니라 "플로우"로 잡는다 (검색/PDP/Cart/Checkout/Reco)
- 성능 지표를 KPI와 같이 본다 (필드 데이터 우선)
- LCP: 상품 이미지 최적화 / 서버 응답 경로 / 3rd-party 스크립트 점검
- INP: 이벤트 핸들러 무거운 작업 제거 / 렌더 범위 축소 / 상호작용 분리
- CLS: 고정 높이 placeholder / 레이아웃 슬롯 미리 잡기
- RN 4구간: Cold start / 화면 전환 / 스크롤 잔렉 / 입력 반응
- 회귀 방지: 성능 예산 + 고위험 구간 PR 규칙 + 릴리즈 게이트


## P1) **설계 트레이드오프 판단**

### 🤖 AI 아이디어

[P1/설계_트레이드오프_판단.md](docs/P1/idea/설계_트레이드오프_판단.md)

> **"정답" 대신 "비용 모델"로 설계 결정을 내리고, 서버/엣지/클라의 로직 배치를 비용(정합성/네트워크/캐시/렌더) 기준으로 판단하는 능력**

- 4개 비용 중 가장 비싼 놈을 먼저 잡는다 (정합성/네트워크/캐시/렌더)
- 서버로 보내야 할 로직: 가격/할인/쿠폰 최종 계산, 재고, 결제 상태 전이
- 5단 캐시 레이어로 백로그를 만든다 (HTTP/CDN/클라데이터/이미지/사전계산)
- 요청 수 줄이기: 배칭, 중복 요청 제거(in-flight dedupe), prefetch
- 실패/재시도 설계: 멱등/중복결제 방지 전제에서만 재시도
- 렌더 비용: 초기진입/리스트/상호작용 3개로 쪼개서 분석

## P2) **확장성(Full-cycle Lite): BE/인프라 이해**

### 🤖 AI 아이디어

[P2/확장성_full_cycle_lite_be_인프라_이해_액션.md](docs/P2/idea/확장성_full_cycle_lite_be_인프라_이해_액션.md)

> **프론트가 BE/인프라를 "실무 임팩트(안정성/전환/KPI/운영)"를 내기 위해 이해하는 능력 — 성능/장애 원인을 서버까지 분해하고, 관측/완화하고, 비용 감각을 갖추는 것**

- 성능/전환 이슈를 '서버까지' 원인 분해한다 (네트워크/캐시/DB/큐)
- 장애를 재현/완화한다 (타임아웃/재시도/서킷브레이커/폴백/롤백)
- 관측 가능하게 만든다 (로그/메트릭/트레이스, 코릴레이션 ID)
- API 계약 문서화 + X-Request-Id로 추적 경로 확보
- 실패 모드 카탈로그 + 프론트 주도 BE/인프라 개선 1개 완료
- 트래픽 비용 절감 + 인프라 운영 지표를 "내 지표"로 보기

## P2) **운영/관측(Observability) & 릴리즈**

### 🤖 AI 아이디어

[P2/운영_관측_릴리즈_통합_운영체계_os_정리.md](docs/P2/idea/운영_관측_릴리즈_통합_운영체계_os_정리.md)

> **KPI(검색 전환율/결제 이탈률/추천 CTR)가 흔들리기 전에 "릴리즈를 제어"하고, 흔들리면 "빠르게 완화"해서 피해를 제한하는 체계**

- 알림은 "에러율"이 아니라 "KPI 방어" 기준으로 설정한다
- 대시보드 3장: Flow Health / Release Health / Change Safety(DORA)
- 릴리즈 운영을 "기술"이 아니라 "정책(게이트)"으로 만든다
- 사고 대응: 재현보다 완화(MTTR) 우선 (범위 규명 → 즉시 완화 → 원인 분석)
- 포스트모템의 끝은 "가드레일 강화"여야 한다 (새 SLO/플래그/알림 개선)

### 👷 개인 아이디어

- 서드파티를 너무 믿지 말자
  - 결제사와 서드파티에 장애가 날 것이라고 확신해라.
  - 응당 되어야 하는 것들이 안 될 때를 대비해 **로깅**을 해두어라
- 로그는 어디서 어떻게 쌓고, 얼마나 관리할 것인가?


## P2) **보안/리스크 방어** (웹 XSS/CSP, 앱 토큰·딥링크·웹뷰/SDK)

### 🤖 AI 아이디어

[P2/보안_리스크_방어.md](docs/P2/idea/보안_리스크_방어.md)

> **프론트가 커머스 핵심 플로우(결제/쿠폰/장바구니/로그인)에서 실제 사고를 막는 설계/코드/정책 액션 — OWASP Top 10의 접근통제/설정오류/취약 컴포넌트/인젝션(XSS 포함) 축을 기준으로**

- 리스크 표면 6개로 쪼개고 오너를 정한다 (입력렌더/인증/딥링크/WebView/SDK/의존성)
- 웹 XSS/CSP: Strict CSP(nonce/hash) + 주입면 제거 + Trusted Types 도입
- 앱 토큰: 보안 저장소(Keychain/Keystore) 사용 + 로그 마스킹 룰 고정
- 딥링크: 검증 링크(Verified Links)로 통일 + 민감 액션은 서버 재확인 필수
- WebView: 도메인 allowlist + postMessage origin/스키마 검증
- 서드파티: 도입 심사 체크리스트 + 킬스위치(원격 비활성화) 준비
- 금지 API/패턴을 린트/리뷰 규칙으로 박는다 (dangerouslySetInnerHTML 등)
